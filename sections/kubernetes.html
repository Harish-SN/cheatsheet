<h2>Kubernetes</h2>
<p>kubectl essentials: contexts & namespaces, deployments/services/ingress, configmaps/secrets, rollouts & scaling,
    logs/exec/port-forward, probes & resources, RBAC, Helm/Kustomize, HPA, maintenance & troubleshooting.</p>
<div class="grid">

    <!-- Kubectl basics -->
    <details open>
        <summary>Kubectl Basics</summary>
        <div class="code">
            <button class="copy" data-target="k8s-basics">Copy</button>
            <pre id="k8s-basics"><code># Version / cluster info
kubectl version --short
kubectl cluster-info
kubectl api-resources
kubectl api-versions

# Get common objects
kubectl get nodes -o wide
kubectl get ns
kubectl get pods -A -o wide
kubectl get svc,deploy,ingress -A

# Describe / YAML view
kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;
kubectl get deploy &lt;name&gt; -n &lt;ns&gt; -o yaml

# Explain fields (built-in docs)
kubectl explain deployment.spec.template.spec.containers
</code></pre>
        </div>
    </details>

    <!-- Contexts & namespaces -->
    <details>
        <summary>Contexts & Namespaces</summary>
        <div class="code">
            <button class="copy" data-target="k8s-contexts">Copy</button>
            <pre id="k8s-contexts"><code># List kubeconfigs in KUBECONFIG (merge)
export KUBECONFIG=~/.kube/config:~/.kube/prod.kubeconfig
kubectl config view --merge --flatten &gt; ~/.kube/merged
mv ~/.kube/merged ~/.kube/config

# Switch context / namespace
kubectl config get-contexts
kubectl config use-context &lt;ctx&gt;
kubectl config set-context --current --namespace=&lt;ns&gt;

# Create namespace
kubectl create ns staging
</code></pre>
        </div>
    </details>

    <!-- Deploy & Service -->
    <details>
        <summary>Deployment & Service (Node/HTTP)</summary>
        <div class="code">
            <button class="copy" data-target="k8s-deploy-svc">Copy</button>
            <pre id="k8s-deploy-svc"><code># Quick deployment (3 replicas) + ClusterIP service
kubectl create deploy web --image=nginx:1.25 --replicas=3 -n default
kubectl expose deploy web --port=80 --target-port=80 --type=ClusterIP

# Update image / restart / scale
kubectl set image deploy/web nginx=nginx:1.25.5
kubectl rollout restart deploy/web
kubectl scale deploy/web --replicas=5

# Rollout status / undo
kubectl rollout status deploy/web
kubectl rollout history deploy/web
kubectl rollout undo deploy/web --to-revision=1
</code></pre>
        </div>
    </details>

    <!-- Ingress -->
    <details>
        <summary>Ingress (Nginx Ingress Controller)</summary>
        <div class="code">
            <button class="copy" data-target="k8s-ingress">Copy</button>
            <pre id="k8s-ingress"><code># Minimal ingress (requires an ingress controller in the cluster)
cat &lt;&lt;'YAML' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web
            port:
              number: 80
YAML

# Check ingress / controller status
kubectl get ingress -A
kubectl get pods -n ingress-nginx -o wide
</code></pre>
        </div>
    </details>

    <!-- ConfigMap & Secret -->
    <details>
        <summary>ConfigMaps & Secrets</summary>
        <div class="code">
            <button class="copy" data-target="k8s-config-secret">Copy</button>
            <pre id="k8s-config-secret"><code># From literals
kubectl create configmap app-cfg --from-literal=APP_ENV=prod
kubectl create secret generic app-secrets --from-literal=DB_PASS='s3cr3t'

# Mount as env or files (snippet)
cat &lt;&lt;'YAML' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata: { name: api }
spec:
  replicas: 2
  selector: { matchLabels: { app: api } }
  template:
    metadata: { labels: { app: api } }
    spec:
      containers:
      - name: api
        image: node:18-alpine
        env:
        - name: APP_ENV
          valueFrom: { configMapKeyRef: { name: app-cfg, key: APP_ENV } }
        - name: DB_PASS
          valueFrom: { secretKeyRef: { name: app-secrets, key: DB_PASS } }
YAML
</code></pre>
        </div>
    </details>

    <!-- Logs, Exec, Port-forward -->
    <details>
        <summary>Logs, Exec & Port-Forward</summary>
        <div class="code">
            <button class="copy" data-target="k8s-ops">Copy</button>
            <pre id="k8s-ops"><code># Pod logs (follow) / specific container
kubectl logs -f deploy/web
kubectl logs -f pod/&lt;pod&gt; -c &lt;container&gt;

# Exec shell
kubectl exec -it pod/&lt;pod&gt; -- bash
kubectl exec -it deploy/web -- sh -- -c "env | sort"

# Port forward service or pod to local
kubectl port-forward svc/web 8080:80
kubectl port-forward pod/&lt;pod&gt; 5432:5432
</code></pre>
        </div>
    </details>

    <!-- Probes & Resources -->
    <details>
        <summary>Probes & Resource Requests/Limits</summary>
        <div class="code">
            <button class="copy" data-target="k8s-probes">Copy</button>
            <pre id="k8s-probes"><code># Add readiness/liveness probes + resources (snippet)
cat &lt;&lt;'YAML' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata: { name: web }
spec:
  replicas: 2
  selector: { matchLabels: { app: web } }
  template:
    metadata: { labels: { app: web } }
    spec:
      containers:
      - name: nginx
        image: nginx:1.25
        resources:
          requests: { cpu: "100m", memory: "128Mi" }
          limits:   { cpu: "500m", memory: "256Mi" }
        livenessProbe:
          httpGet: { path: /, port: 80 }
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet: { path: /, port: 80 }
          initialDelaySeconds: 5
          periodSeconds: 5
YAML
</code></pre>
        </div>
    </details>

    <!-- RBAC -->
    <details>
        <summary>RBAC: ServiceAccount, Role & Binding</summary>
        <div class="code">
            <button class="copy" data-target="k8s-rbac">Copy</button>
            <pre id="k8s-rbac"><code># Minimal read-only role on a namespace
cat &lt;&lt;'YAML' | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata: { name: viewer, namespace: default }
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata: { name: view-role, namespace: default }
rules:
- apiGroups: [""]
  resources: ["pods","services","endpoints","configmaps"]
  verbs: ["get","list","watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata: { name: view-bind, namespace: default }
subjects:
- kind: ServiceAccount
  name: viewer
  namespace: default
roleRef:
  kind: Role
  name: view-role
  apiGroup: rbac.authorization.k8s.io
YAML
</code></pre>
        </div>
    </details>

    <!-- Helm -->
    <details>
        <summary>Helm (Charts)</summary>
        <div class="code">
            <button class="copy" data-target="k8s-helm">Copy</button>
            <pre id="k8s-helm"><code># Install a chart
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update
helm install myredis bitnami/redis --namespace data --create-namespace

# Values overrides
helm upgrade --install web ./chart -f values.prod.yaml

# List / diff / uninstall
helm list -A
helm get values web
helm uninstall myredis -n data
</code></pre>
        </div>
    </details>

    <!-- Kustomize -->
    <details>
        <summary>Kustomize (patches & overlays)</summary>
        <div class="code">
            <button class="copy" data-target="k8s-kustomize">Copy</button>
            <pre id="k8s-kustomize"><code># kustomization.yaml example
cat &lt;&lt;'YAML' &gt; kustomization.yaml
resources:
  - base.yaml
patches:
  - target:
      kind: Deployment
      name: web
    patch: |-
      - op: replace
        path: /spec/replicas
        value: 3
YAML

kubectl apply -k .
</code></pre>
        </div>
    </details>

    <!-- Maintenance -->
    <details>
        <summary>Maintenance: Cordon, Drain, Uncordon</summary>
        <div class="code">
            <button class="copy" data-target="k8s-maint">Copy</button>
            <pre id="k8s-maint"><code># Safely move workloads off a node
kubectl cordon &lt;node&gt;          # mark unschedulable
kubectl drain &lt;node&gt; --ignore-daemonsets --delete-emptydir-data --force
# After maintenance:
kubectl uncordon &lt;node&gt;

# Node / pod usage (requires metrics-server)
kubectl top node
kubectl top pod -A
</code></pre>
        </div>
    </details>

    <!-- Autoscaling -->
    <details>
        <summary>HPA: Horizontal Pod Autoscaler</summary>
        <div class="code">
            <button class="copy" data-target="k8s-hpa">Copy</button>
            <pre id="k8s-hpa"><code># CPU-based autoscaling (needs metrics-server)
kubectl autoscale deploy web --cpu-percent=70 --min=2 --max=10

# View HPA
kubectl get hpa -A
kubectl describe hpa web
</code></pre>
        </div>
    </details>

    <!-- JSONPath & Selectors -->
    <details>
        <summary>JSONPath, Labels & Selectors</summary>
        <div class="code">
            <button class="copy" data-target="k8s-jsonpath">Copy</button>
            <pre id="k8s-jsonpath"><code># Label & select
kubectl label pod &lt;pod&gt; tier=backend
kubectl get pods -l tier=backend

# JSONPath examples
kubectl get nodes -o jsonpath='{.items[*].metadata.name}'
kubectl get pods -n kube-system -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'

# Wide output and sorting
kubectl get pods -o wide --sort-by=.status.startTime
</code></pre>
        </div>
    </details>

    <!-- Troubleshooting -->
    <details>
        <summary>Troubleshooting & Debug</summary>
        <div class="code">
            <button class="copy" data-target="k8s-troubleshoot">Copy</button>
            <pre id="k8s-troubleshoot"><code># Events & describe
kubectl get events --sort-by=.lastTimestamp -A | tail -n 50
kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;

# Ephemeral debug container (kubectl debug)
kubectl debug pod/&lt;pod&gt; -n &lt;ns&gt; -it --image=busybox:1.36 --target=&lt;container&gt;

# DNS test (busybox)
kubectl run -it dns-test --rm --image=busybox:1.36 --restart=Never -- nslookup kubernetes.default

# CrashLoopBackOff: get last logs
kubectl logs --previous pod/&lt;pod&gt; -c &lt;container&gt;

# Stuck terminating
kubectl delete pod &lt;pod&gt; --grace-period=0 --force -n &lt;ns&gt;
</code></pre>
        </div>
    </details>

</div>